"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/openai.js":
/*!***********************!*\
  !*** ./lib/openai.js ***!
  \***********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   askQuestion: () => (/* binding */ askQuestion),\n/* harmony export */   humanizeAnswer: () => (/* binding */ humanizeAnswer),\n/* harmony export */   paraphraseAnswer: () => (/* binding */ paraphraseAnswer)\n/* harmony export */ });\nconst GEMINI_API_KEY = 'add your gemini api key here';\nconst askQuestion = async (question)=>{\n    try {\n        var _data_candidates__content_parts_, _data_candidates__content_parts, _data_candidates__content, _data_candidates_, _data_candidates;\n        const response = await fetch(\"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=\".concat(GEMINI_API_KEY), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                contents: [\n                    {\n                        parts: [\n                            {\n                                text: \"You are a helpful assistant that provides clear, accurate answers to questions. Always be informative and concise. Question: \".concat(question)\n                            }\n                        ]\n                    }\n                ],\n                generationConfig: {\n                    temperature: 0.7,\n                    topK: 40,\n                    topP: 0.95,\n                    maxOutputTokens: 1024\n                }\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"API request failed: \".concat(response.status));\n        }\n        const data = await response.json();\n        return ((_data_candidates = data.candidates) === null || _data_candidates === void 0 ? void 0 : (_data_candidates_ = _data_candidates[0]) === null || _data_candidates_ === void 0 ? void 0 : (_data_candidates__content = _data_candidates_.content) === null || _data_candidates__content === void 0 ? void 0 : (_data_candidates__content_parts = _data_candidates__content.parts) === null || _data_candidates__content_parts === void 0 ? void 0 : (_data_candidates__content_parts_ = _data_candidates__content_parts[0]) === null || _data_candidates__content_parts_ === void 0 ? void 0 : _data_candidates__content_parts_.text) || 'Sorry, I could not generate an answer.';\n    } catch (error) {\n        console.error('Error calling Gemini API:', error);\n        throw new Error('Failed to get answer from AI. Please try again.');\n    }\n};\nconst paraphraseAnswer = async (originalAnswer)=>{\n    try {\n        var _data_candidates__content_parts_, _data_candidates__content_parts, _data_candidates__content, _data_candidates_, _data_candidates;\n        const response = await fetch(\"https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=\".concat(GEMINI_API_KEY), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                contents: [\n                    {\n                        parts: [\n                            {\n                                text: \"Paraphrase the following text to make it unique while keeping the original meaning, improving clarity and readability. Avoid plagiarism, maintain a natural tone, and ensure proper grammar and flow: \".concat(originalAnswer)\n                            }\n                        ]\n                    }\n                ],\n                generationConfig: {\n                    temperature: 0.5,\n                    topK: 40,\n                    topP: 0.95,\n                    maxOutputTokens: 1024\n                }\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"API request failed: \".concat(response.status));\n        }\n        const data = await response.json();\n        return ((_data_candidates = data.candidates) === null || _data_candidates === void 0 ? void 0 : (_data_candidates_ = _data_candidates[0]) === null || _data_candidates_ === void 0 ? void 0 : (_data_candidates__content = _data_candidates_.content) === null || _data_candidates__content === void 0 ? void 0 : (_data_candidates__content_parts = _data_candidates__content.parts) === null || _data_candidates__content_parts === void 0 ? void 0 : (_data_candidates__content_parts_ = _data_candidates__content_parts[0]) === null || _data_candidates__content_parts_ === void 0 ? void 0 : _data_candidates__content_parts_.text) || 'Sorry, I could not paraphrase the answer.';\n    } catch (error) {\n        console.error('Error paraphrasing answer:', error);\n        throw new Error('Failed to paraphrase answer. Please try again.');\n    }\n};\nasync function humanizeAnswer(answer) {\n    try {\n        const response = await fetch(\"https://generativelanguage.googleapis.com/v1/models/gemini-2.0-flash:generateContent?key=\".concat(GEMINI_API_KEY), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                contents: [\n                    {\n                        parts: [\n                            {\n                                text: \"Humanize this text so it sounds professional, clear, and approachable, while keeping the original message intact. Remove any overly complex or robotic phrasing:\\n\\n\".concat(answer)\n                            }\n                        ]\n                    }\n                ]\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const data = await response.json();\n        if (data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts) {\n            return data.candidates[0].content.parts[0].text;\n        } else {\n            throw new Error('Invalid response format');\n        }\n    } catch (error) {\n        console.error('Error humanizing answer:', error);\n        throw error;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFLQyxTQUFTLENBQUM7Z0JBQ25CQyxVQUFVO29CQUFDO3dCQUNUQyxPQUFPOzRCQUFDO2dDQUNOQyxNQUFNLHVLQUE4SyxPQUFQaUI7NEJBQy9LO3lCQUFFO29CQUNKO2lCQUFFO1lBQ0o7UUFDRjtRQUVBLElBQUksQ0FBQzFCLFNBQVNlLEVBQUUsRUFBRTtZQUNoQixNQUFNLElBQUlDLE1BQU0sdUJBQXVDLE9BQWhCaEIsU0FBU2lCLE1BQU07UUFDeEQ7UUFFQSxNQUFNbEIsT0FBTyxNQUFNQyxTQUFTa0IsSUFBSTtRQUVoQyxJQUFJbkIsS0FBS29CLFVBQVUsSUFBSXBCLEtBQUtvQixVQUFVLENBQUMsRUFBRSxJQUFJcEIsS0FBS29CLFVBQVUsQ0FBQyxFQUFFLENBQUNDLE9BQU8sSUFBSXJCLEtBQUtvQixVQUFVLENBQUMsRUFBRSxDQUFDQyxPQUFPLENBQUNaLEtBQUssRUFBRTtZQUMzRyxPQUFPVCxLQUFLb0IsVUFBVSxDQUFDLEVBQUUsQ0FBQ0MsT0FBTyxDQUFDWixLQUFLLENBQUMsRUFBRSxDQUFDQyxJQUFJO1FBQ2pELE9BQU87WUFDTCxNQUFNLElBQUlPLE1BQU07UUFDbEI7SUFDRixFQUFFLE9BQU9LLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLDRCQUE0QkE7UUFDMUMsTUFBTUE7SUFDUjtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXG4xY2thclxcRGVza3RvcFxcTVlGSUxFU1xcQ29kaW5nXFxSZWFjdFxcQWlRdWVzdGlvblNvbHZlclxcYWktcXVlc3Rpb24tc29sdmVyXFxsaWJcXG9wZW5haS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmNvbnN0IEdFTUlOSV9BUElfS0VZID0gJ2FkZCB5b3VyIGdlbWluaSBhcGkga2V5IGhlcmUnO1xuXG5leHBvcnQgY29uc3QgYXNrUXVlc3Rpb24gPSBhc3luYyAocXVlc3Rpb24pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGBodHRwczovL2dlbmVyYXRpdmVsYW5ndWFnZS5nb29nbGVhcGlzLmNvbS92MWJldGEvbW9kZWxzL2dlbWluaS0yLjAtZmxhc2g6Z2VuZXJhdGVDb250ZW50P2tleT0ke0dFTUlOSV9BUElfS0VZfWAsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBjb250ZW50czogW3tcbiAgICAgICAgICBwYXJ0czogW3tcbiAgICAgICAgICAgIHRleHQ6IGBZb3UgYXJlIGEgaGVscGZ1bCBhc3Npc3RhbnQgdGhhdCBwcm92aWRlcyBjbGVhciwgYWNjdXJhdGUgYW5zd2VycyB0byBxdWVzdGlvbnMuIEFsd2F5cyBiZSBpbmZvcm1hdGl2ZSBhbmQgY29uY2lzZS4gUXVlc3Rpb246ICR7cXVlc3Rpb259YFxuICAgICAgICAgIH1dXG4gICAgICAgIH1dLFxuICAgICAgICBnZW5lcmF0aW9uQ29uZmlnOiB7XG4gICAgICAgICAgdGVtcGVyYXR1cmU6IDAuNyxcbiAgICAgICAgICB0b3BLOiA0MCxcbiAgICAgICAgICB0b3BQOiAwLjk1LFxuICAgICAgICAgIG1heE91dHB1dFRva2VuczogMTAyNFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBUEkgcmVxdWVzdCBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgcmV0dXJuIGRhdGEuY2FuZGlkYXRlcz8uWzBdPy5jb250ZW50Py5wYXJ0cz8uWzBdPy50ZXh0IHx8ICdTb3JyeSwgSSBjb3VsZCBub3QgZ2VuZXJhdGUgYW4gYW5zd2VyLic7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2FsbGluZyBHZW1pbmkgQVBJOicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgYW5zd2VyIGZyb20gQUkuIFBsZWFzZSB0cnkgYWdhaW4uJyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBwYXJhcGhyYXNlQW5zd2VyID0gYXN5bmMgKG9yaWdpbmFsQW5zd2VyKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgaHR0cHM6Ly9nZW5lcmF0aXZlbGFuZ3VhZ2UuZ29vZ2xlYXBpcy5jb20vdjFiZXRhL21vZGVscy9nZW1pbmktMi4wLWZsYXNoOmdlbmVyYXRlQ29udGVudD9rZXk9JHtHRU1JTklfQVBJX0tFWX1gLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgY29udGVudHM6IFt7XG4gICAgICAgICAgcGFydHM6IFt7XG4gICAgICAgICAgICB0ZXh0OiBgUGFyYXBocmFzZSB0aGUgZm9sbG93aW5nIHRleHQgdG8gbWFrZSBpdCB1bmlxdWUgd2hpbGUga2VlcGluZyB0aGUgb3JpZ2luYWwgbWVhbmluZywgaW1wcm92aW5nIGNsYXJpdHkgYW5kIHJlYWRhYmlsaXR5LiBBdm9pZCBwbGFnaWFyaXNtLCBtYWludGFpbiBhIG5hdHVyYWwgdG9uZSwgYW5kIGVuc3VyZSBwcm9wZXIgZ3JhbW1hciBhbmQgZmxvdzogJHtvcmlnaW5hbEFuc3dlcn1gXG4gICAgICAgICAgfV1cbiAgICAgICAgfV0sXG4gICAgICAgIGdlbmVyYXRpb25Db25maWc6IHtcbiAgICAgICAgICB0ZW1wZXJhdHVyZTogMC41LFxuICAgICAgICAgIHRvcEs6IDQwLFxuICAgICAgICAgIHRvcFA6IDAuOTUsXG4gICAgICAgICAgbWF4T3V0cHV0VG9rZW5zOiAxMDI0XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFQSSByZXF1ZXN0IGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4gZGF0YS5jYW5kaWRhdGVzPy5bMF0/LmNvbnRlbnQ/LnBhcnRzPy5bMF0/LnRleHQgfHwgJ1NvcnJ5LCBJIGNvdWxkIG5vdCBwYXJhcGhyYXNlIHRoZSBhbnN3ZXIuJztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJhcGhyYXNpbmcgYW5zd2VyOicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJhcGhyYXNlIGFuc3dlci4gUGxlYXNlIHRyeSBhZ2Fpbi4nKTtcbiAgfVxufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGh1bWFuaXplQW5zd2VyKGFuc3dlcikge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYGh0dHBzOi8vZ2VuZXJhdGl2ZWxhbmd1YWdlLmdvb2dsZWFwaXMuY29tL3YxL21vZGVscy9nZW1pbmktMi4wLWZsYXNoOmdlbmVyYXRlQ29udGVudD9rZXk9JHtHRU1JTklfQVBJX0tFWX1gLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGNvbnRlbnRzOiBbe1xuICAgICAgICAgIHBhcnRzOiBbe1xuICAgICAgICAgICAgdGV4dDogYEh1bWFuaXplIHRoaXMgdGV4dCBzbyBpdCBzb3VuZHMgcHJvZmVzc2lvbmFsLCBjbGVhciwgYW5kIGFwcHJvYWNoYWJsZSwgd2hpbGUga2VlcGluZyB0aGUgb3JpZ2luYWwgbWVzc2FnZSBpbnRhY3QuIFJlbW92ZSBhbnkgb3Zlcmx5IGNvbXBsZXggb3Igcm9ib3RpYyBwaHJhc2luZzpcXG5cXG4ke2Fuc3dlcn1gXG4gICAgICAgICAgfV1cbiAgICAgICAgfV1cbiAgICAgIH0pXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgIGlmIChkYXRhLmNhbmRpZGF0ZXMgJiYgZGF0YS5jYW5kaWRhdGVzWzBdICYmIGRhdGEuY2FuZGlkYXRlc1swXS5jb250ZW50ICYmIGRhdGEuY2FuZGlkYXRlc1swXS5jb250ZW50LnBhcnRzKSB7XG4gICAgICByZXR1cm4gZGF0YS5jYW5kaWRhdGVzWzBdLmNvbnRlbnQucGFydHNbMF0udGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlc3BvbnNlIGZvcm1hdCcpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBodW1hbml6aW5nIGFuc3dlcjonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJHRU1JTklfQVBJX0tFWSIsImFza1F1ZXN0aW9uIiwicXVlc3Rpb24iLCJkYXRhIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImNvbnRlbnRzIiwicGFydHMiLCJ0ZXh0IiwiZ2VuZXJhdGlvbkNvbmZpZyIsInRlbXBlcmF0dXJlIiwidG9wSyIsInRvcFAiLCJtYXhPdXRwdXRUb2tlbnMiLCJvayIsIkVycm9yIiwic3RhdHVzIiwianNvbiIsImNhbmRpZGF0ZXMiLCJjb250ZW50IiwiZXJyb3IiLCJjb25zb2xlIiwicGFyYXBocmFzZUFuc3dlciIsIm9yaWdpbmFsQW5zd2VyIiwiaHVtYW5pemVBbnN3ZXIiLCJhbnN3ZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/openai.js\n"));

/***/ })

});